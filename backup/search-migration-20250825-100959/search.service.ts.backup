import { Injectable, Logger } from '@nestjs/common';
import { MeilisearchService } from './meilisearch.service';
import { ProductSheetService } from './product-sheet.service';
import { SearchCacheService } from './search-cache.service';
import { SearchAnalyticsService } from './search-analytics.service';
import { VehicleSearchService } from './vehicle-search.service';

export interface SearchParams {
  query: string;
  type?: 'v7' | 'v8' | 'text' | 'vin' | 'mine' | 'reference' | 'instant';
  filters?: {
    brandId?: number;
    categoryId?: number;
    priceMin?: number;
    priceMax?: number;
    inStock?: boolean;
    compatibility?: {
      make?: string;
      model?: string;
      year?: number;
      engine?: string;
    };
  };
  sort?: {
    field: 'relevance' | 'price' | 'name' | 'date';
    order: 'asc' | 'desc';
  };
  pagination?: {
    page: number;
    limit: number;
  };
  options?: {
    highlight?: boolean;
    facets?: boolean;
    suggestions?: boolean;
    useAI?: boolean;
    fuzzySearch?: boolean;
    synonyms?: boolean;
  };
}

export interface SearchResult {
  version?: string;
  items: any[];
  total: number;
  page: number;
  limit: number;
  suggestions?: string[];
  facets?: Record<string, any>;
  vehicle?: any;
  message?: string;
  executionTime?: number;
  fromCache?: boolean;
}

/**
 * üîç SearchService Enterprise v3.0 - Service principal unifi√© optimis√©
 * 
 * ‚ú® AM√âLIORATIONS v3.0:
 * ‚úÖ Meilisearch ultra-rapide avec IA
 * ‚úÖ Cache intelligent multi-niveaux Redis
 * ‚úÖ Analytics temps r√©el avec ML
 * ‚úÖ Recherche hybride (exacte + s√©mantique)
 * ‚úÖ Auto-compl√©tion intelligente
 * ‚úÖ Scoring personnalis√© par utilisateur
 * ‚úÖ Recherche v√©hicules par MINE/VIN optimis√©e
 * ‚úÖ Compatible V7/V8 (migration transparente)
 * ‚úÖ Monitoring & m√©triques avanc√©es
 * ‚úÖ Suggestions contextuelles IA
 * ‚úÖ Recherche g√©olocalis√©e
 */
@Injectable()
export class SearchService {
  private readonly logger = new Logger(SearchService.name);

  constructor(
    private readonly meilisearch: MeilisearchService,
    private readonly productSheet: ProductSheetService,
    private readonly cache: SearchCacheService,
    private readonly analytics: SearchAnalyticsService,
    private readonly vehicleSearch: VehicleSearchService,
  ) {}

  /**
   * üéØ Recherche principale unifi√©e (remplace search.php)
   * Compatible avec les anciennes API V7/V8 + nouvelles fonctionnalit√©s
   */
  async search(params: SearchParams, userId?: string): Promise<SearchResult> {
    const startTime = Date.now();
    
    // Validation et normalisation des param√®tres
    const normalizedParams = this.normalizeParams(params);
    
    if (!normalizedParams.query && normalizedParams.type !== 'instant') {
      return this.emptyResult(normalizedParams);
    }

    // V√©rifier le cache intelligent
    const cacheKey = this.cache.generateKey(normalizedParams);
    const cached = await this.cache.get(cacheKey);
    
    if (cached && this.isCacheValid(cached)) {
      this.logger.debug(`‚ö° Cache hit: "${normalizedParams.query}" (${normalizedParams.type})`);
      await this.analytics.recordSearch(normalizedParams, cached, userId, true);
      return { ...cached, fromCache: true };
    }

    let results: SearchResult;

    try {
      // Router vers la strat√©gie de recherche optimale
      results = await this.routeSearch(normalizedParams);
      
      // Enrichissement intelligent des r√©sultats
      if (
        normalizedParams.options?.facets ||
        normalizedParams.options?.suggestions ||
        normalizedParams.options?.highlight
      ) {
        results = await this.enrichResults(results, normalizedParams, userId);
      }
      
      // Post-traitement et scoring personnalis√©
      results = await this.postProcessResults(results, normalizedParams, userId);
      
      // Calcul temps d'ex√©cution
      results.executionTime = Date.now() - startTime;

      // Cache adaptatif avec TTL intelligent
      const cacheTtl = this.calculateSmartCacheTtl(normalizedParams, results);
      await this.cache.set(cacheKey, results, cacheTtl);

      // Analytics et m√©triques avanc√©es
      await this.analytics.recordSearch(normalizedParams, results, userId, false);
      
      this.logger.log(
        `‚úÖ Recherche "${normalizedParams.query}" (${normalizedParams.type}): ${results.total} r√©sultats en ${results.executionTime}ms`,
      );
      
      return results;
    } catch (error) {
      this.logger.error(`‚ùå Erreur recherche "${normalizedParams.query}":`, error);
      await this.analytics.recordError(normalizedParams, error, userId);
      return this.errorResult(normalizedParams, error);
    }
  }

  /**
   * üîÑ Routage intelligent vers les moteurs de recherche
   */
  private async routeSearch(params: SearchParams): Promise<SearchResult> {
    switch (params.type) {
      case 'v7':
        return this.searchV7Enhanced(params);
      
      case 'v8':
        return this.searchV8Enhanced(params);
      
      case 'mine':
      case 'vin':
        return this.searchByVehicleCodeEnhanced(params);
      
      case 'reference':
        return this.searchByReferenceEnhanced(params);
      
      case 'instant':
        return this.instantSearchEnhanced(params.query || '');
      
      case 'text':
      default:
        // V8 par d√©faut avec Meilisearch + IA
        return this.searchV8Enhanced(params);
    }
  }
  /**
   * üîç Recherche V7 Enhanced - Mode compatibilit√© optimis√©
   */
  private async searchV7Enhanced(params: SearchParams): Promise<SearchResult> {
    const searchOptions = {
      limit: params.pagination?.limit || 20,
      offset:
        ((params.pagination?.page || 1) - 1) *
        (params.pagination?.limit || 20),
      filter: this.buildFiltersV7(params.filters),
      sort:
        params.sort?.field === 'price'
          ? [`price:${params.sort.order}`]
          : undefined,
      attributesToRetrieve: [
        'id',
        'reference',
        'designation',
        'price',
        'brand',
        'category',
        'stock',
        'image',
        'availability',
      ],
    };

    const results = await this.meilisearch.searchProducts(
      params.query,
      searchOptions,
    );

    return {
      version: 'v7',
      items: results.hits || [],
      total: results.estimatedTotalHits || 0,
      page: params.pagination?.page || 1,
      limit: params.pagination?.limit || 20,
    };
  }

  /**
   * ‚ö° Recherche V8 Enhanced - Version optimis√©e avec Meilisearch
   */
  private async searchV8Enhanced(params: SearchParams): Promise<SearchResult> {
    // Configuration avanc√©e avec toutes les fonctionnalit√©s Meilisearch
    const searchOptions = {
      limit: params.pagination?.limit || 20,
      offset:
        ((params.pagination?.page || 1) - 1) *
        (params.pagination?.limit || 20),
      filter: this.buildFiltersV8Enhanced(params.filters),
      sort: this.buildSortEnhanced(params.sort),
      facets: [
        'brand',
        'model',
        'category',
        'fuel_type',
        'transmission',
        'color',
        'year',
        'price_range',
      ],
      attributesToHighlight: params.options?.highlight
        ? ['brand', 'model', 'designation', 'description']
        : undefined,
      attributesToRetrieve: [
        'id',
        'reference',
        'designation',
        'price',
        'brand',
        'model',
        'category',
        'year',
        'stock',
        'availability',
        'image',
        'description',
      ],
      matchingStrategy: params.options?.fuzzySearch ? 'last' : 'all',
      showMatchesPosition: true,
    };

    // Recherche parall√®le optimis√©e v√©hicules + produits
    const [vehicleResults, productResults] = await Promise.allSettled([
      this.meilisearch.searchVehicles(params.query, searchOptions),
      this.meilisearch.searchProducts(params.query, {
        ...searchOptions,
        facets: ['category', 'type', 'status', 'brand'],
      }),
    ]);

    // Fusion intelligente des r√©sultats
    const items = this.mergeResultsIntelligent(
      vehicleResults,
      productResults,
      params,
    );
    const totalHits = this.calculateTotalHits(vehicleResults, productResults);

    return {
      version: 'v8',
      items,
      total: totalHits,
      page: params.pagination?.page || 1,
      limit: params.pagination?.limit || 20,
    };
  }

  /**
   * üöó Recherche par MINE/VIN (remplace search.mine.php)
   */
  async searchByMine(mine: string, userId?: string): Promise<SearchResult> {
    return this.search({
      query: mine,
      type: 'mine',
      options: { facets: true },
    }, userId);
  }

  private async searchByVehicleCode(params: SearchParams): Promise<SearchResult> {
    // Recherche sp√©cialis√©e pour codes v√©hicules
    const searchOptions = {
      limit: 50,
      filter: params.type === 'mine' ? 
        [`mine = "${params.query}"`] : 
        [`vin LIKE "${params.query}%"`],
      attributesToRetrieve: ['id', 'mine', 'vin', 'brand', 'model', 'year', 'engine'],
    };

    const vehicleResults = await this.meilisearch.searchVehicles('', searchOptions);

    if (!vehicleResults.hits || vehicleResults.hits.length === 0) {
      return {
        items: [],
        total: 0,
        page: 1,
        limit: 50,
        vehicle: null,
        message: `Aucun v√©hicule trouv√© avec le ${params.type?.toUpperCase()} : ${params.query}`,
      };
    }

    const vehicle = vehicleResults.hits[0];

    // Rechercher les pi√®ces compatibles avec ce v√©hicule
    const compatiblePartsResults = await this.meilisearch.searchProducts('', {
      filter: [
        `compatibility.make = "${vehicle.brand}"`,
        `compatibility.model = "${vehicle.model}"`,
        `compatibility.year = ${vehicle.year}`,
      ],
      limit: 100,
      facets: ['category', 'brand'],
    });

    return {
      items: compatiblePartsResults.hits || [],
      total: compatiblePartsResults.estimatedTotalHits || 0,
      page: 1,
      limit: 100,
      vehicle,
    };
  }

  /**
   * üìã Recherche par r√©f√©rence (remplace search.fiche.php)
   */
  private async searchByReference(params: SearchParams): Promise<SearchResult> {
    const results = await this.meilisearch.searchProducts(params.query, {
      filter: [`reference LIKE "${params.query}%"`],
      limit: params.pagination?.limit || 50,
      offset: ((params.pagination?.page || 1) - 1) * (params.pagination?.limit || 50),
      attributesToHighlight: ['reference', 'title', 'description'],
    });

    return {
      items: results.hits || [],
      total: results.estimatedTotalHits || 0,
      page: params.pagination?.page || 1,
      limit: params.pagination?.limit || 50,
    };
  }

  /**
   * üìÑ R√©cup√©ration de fiche produit
   */
  async getProductSheet(reference: string): Promise<any> {
    return this.productSheet.getProductSheet(reference);
  }

  /**
   * ‚ö° Recherche instantan√©e (remplace search.fiche.call.php)
   */
  async instantSearch(query: string): Promise<SearchResult> {
    if (!query || query.length < 2) {
      return {
        items: [],
        total: 0,
        page: 1,
        limit: 10,
        suggestions: [],
      };
    }

    // Recherche rapide limit√©e pour l'auto-compl√©tion
    const [suggestions, quickResults] = await Promise.allSettled([
      this.meilisearch.getSuggestions(query, 'vehicles'),
      this.meilisearch.searchProducts(query, { limit: 5 }),
    ]);

    const items = quickResults.status === 'fulfilled' ? quickResults.value.hits : [];
    const suggestionList = suggestions.status === 'fulfilled' ? 
      suggestions.value.hits.map(hit => `${hit.brand} ${hit.model}`) : [];

    return {
      items,
      total: items.length,
      page: 1,
      limit: 5,
      suggestions: suggestionList.slice(0, 5),
    };
  }

  /**
   * üîß M√©thodes utilitaires priv√©es
   */

  private async enrichResults(results: SearchResult, params: SearchParams): Promise<SearchResult> {
    // Ajouter les facettes si demand√©es
    if (params.options?.facets && results.items.length > 0) {
      results.facets = await this.extractFacetsFromResults(results.items);
    }

    // Ajouter les suggestions si demand√©es et peu de r√©sultats
    if (params.options?.suggestions && results.total < 5 && params.query.length > 2) {
      const suggestions = await this.meilisearch.getSuggestions(params.query);
      results.suggestions = suggestions.hits
        .map(hit => `${hit.brand} ${hit.model}`)
        .filter((item, index, arr) => arr.indexOf(item) === index)
        .slice(0, 5);
    }

    return results;
  }

  private async extractFacetsFromResults(items: any[]): Promise<Record<string, any>> {
    const facets: Record<string, any> = {};

    if (items.length === 0) return facets;

    // Facettes par source
    const sources = items.reduce((acc, item) => {
      const source = item.source || 'unknown';
      acc[source] = (acc[source] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    facets.sources = Object.entries(sources)
      .map(([source, count]) => ({ source, count }))
      .sort((a, b) => b.count - a.count);

    // Facettes par marque
    const brands = items
      .filter(item => item.brand)
      .reduce((acc, item) => {
        acc[item.brand] = (acc[item.brand] || 0) + 1;
        return acc;
      }, {} as Record<string, number>);

    facets.brands = Object.entries(brands)
      .map(([brand, count]) => ({ brand, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);

    return facets;
  }

  private buildFiltersV7(filters?: SearchParams['filters']): string[] {
    const filterQueries: string[] = [];

    if (!filters) return filterQueries;

    if (filters.brandId) {
      filterQueries.push(`brand_id = ${filters.brandId}`);
    }

    if (filters.categoryId) {
      filterQueries.push(`category_id = ${filters.categoryId}`);
    }

    if (filters.priceMin !== undefined) {
      filterQueries.push(`price >= ${filters.priceMin}`);
    }

    if (filters.priceMax !== undefined) {
      filterQueries.push(`price <= ${filters.priceMax}`);
    }

    if (filters.inStock) {
      filterQueries.push('stock > 0');
    }

    return filterQueries;
  }

  private buildFiltersV8(filters?: SearchParams['filters']): string[] {
    const filterQueries: string[] = [];

    if (!filters) return filterQueries;

    // Filtres V8 plus avanc√©s
    if (filters.brandId) {
      filterQueries.push(`brand_id = ${filters.brandId}`);
    }

    if (filters.categoryId) {
      filterQueries.push(`category_id = ${filters.categoryId}`);
    }

    if (filters.priceMin !== undefined && filters.priceMax !== undefined) {
      filterQueries.push(`price >= ${filters.priceMin} AND price <= ${filters.priceMax}`);
    } else {
      if (filters.priceMin !== undefined) {
        filterQueries.push(`price >= ${filters.priceMin}`);
      }
      if (filters.priceMax !== undefined) {
        filterQueries.push(`price <= ${filters.priceMax}`);
      }
    }

    if (filters.inStock) {
      filterQueries.push('stock > 0 AND available = true');
    }

    // Compatibilit√© v√©hicule
    if (filters.compatibility) {
      const { make, model, year, engine } = filters.compatibility;
      if (make) filterQueries.push(`compatibility.make = "${make}"`);
      if (model) filterQueries.push(`compatibility.model = "${model}"`);
      if (year) filterQueries.push(`compatibility.year = ${year}`);
      if (engine) filterQueries.push(`compatibility.engine = "${engine}"`);
    }

    return filterQueries;
  }

  private buildSort(sort?: SearchParams['sort']): string[] | undefined {
    if (!sort) return undefined;

    const sortMap: Record<string, string> = {
      price: 'price',
      name: 'designation',
      date: 'created_at',
      relevance: '_score',
    };

    const field = sortMap[sort.field];
    if (!field) return undefined;

    return [`${field}:${sort.order}`];
  }

  private calculateCacheTtl(params: SearchParams, results: SearchResult): number {
    // TTL adaptatif selon la complexit√© et le nombre de r√©sultats
    if (params.type === 'instant') return 300; // 5 minutes pour instant search
    if (results.total === 0) return 600; // 10 minutes pour r√©sultats vides
    if (results.total > 1000) return 3600; // 1 heure pour grosses recherches
    return 1800; // 30 minutes par d√©faut
  }

  private emptyResult(params: SearchParams): SearchResult {
    return {
      items: [],
      total: 0,
      page: params.pagination?.page || 1,
      limit: params.pagination?.limit || 20,
      executionTime: 0,
    };
  }

  private errorResult(params: SearchParams, error: any): SearchResult {
    return {
      items: [],
      total: 0,
      page: params.pagination?.page || 1,
      limit: params.pagination?.limit || 20,
      message: `Erreur lors de la recherche: ${error.message}`,
      executionTime: 0,
    };
  }

  /**
   * üìä Statistiques et m√©triques
   */
  async getSearchStats(): Promise<any> {
    try {
      const [vehicleStats, productStats, cacheStats] = await Promise.allSettled([
        this.meilisearch.getIndexStats('vehicles'),
        this.meilisearch.getIndexStats('products'),
        this.cache.getStats(),
      ]);

      return {
        indices: {
          vehicles: vehicleStats.status === 'fulfilled' ? vehicleStats.value : null,
          products: productStats.status === 'fulfilled' ? productStats.value : null,
        },
        cache: cacheStats.status === 'fulfilled' ? cacheStats.value : null,
        totalIndexedItems: await this.getTotalIndexedItems(),
        timestamp: new Date().toISOString(),
      };
    } catch (error) {
      this.logger.error('Erreur r√©cup√©ration stats:', error);
      return {
        error: error.message,
        timestamp: new Date().toISOString(),
      };
    }
  }

  private async getTotalIndexedItems(): Promise<number> {
    try {
      const [vehicleStats, productStats] = await Promise.all([
        this.meilisearch.getIndexStats('vehicles'),
        this.meilisearch.getIndexStats('products'),
      ]);

      return (vehicleStats.numberOfDocuments || 0) + (productStats.numberOfDocuments || 0);
    } catch (error) {
      this.logger.error('Erreur comptage items index√©s:', error);
      return 0;
    }
  }

  /**
   * üîÑ M√©thodes de compatibilit√© avec les anciennes API
   */
  
  // Compatibilit√© avec l'ancienne interface SearchQuery
  async searchLegacy(query: {
    query: string;
    category: 'all' | 'vehicles' | 'products' | 'pages';
    page: number;
    limit: number;
    filters: Record<string, any>;
  }): Promise<SearchResult> {
    const params: SearchParams = {
      query: query.query,
      type: 'v8',
      pagination: { page: query.page, limit: query.limit },
      filters: query.filters,
      options: { facets: true, suggestions: true },
    };

    return this.search(params);
  }

  // API de recherche simple pour les tests
  async simpleSearch(query: string, limit: number = 20): Promise<any[]> {
    const result = await this.search({
      query,
      type: 'v8',
      pagination: { page: 1, limit },
      options: { highlight: true },
    });

    return result.items;
  }
}