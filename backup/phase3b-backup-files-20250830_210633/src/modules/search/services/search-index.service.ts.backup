import { Injectable, Logger } from '@nestjs/common';
import { ElasticsearchService } from '@nestjs/elasticsearch';
import { ConfigService } from '@nestjs/config';

export interface IndexStats {
  totalDocuments: number;
  totalSize: string;
  indices: {
    name: string;
    documents: number;
    size: string;
    lastUpdated: string;
  }[];
}

export interface ReindexOptions {
  index: string;
  batchSize: number;
  force: boolean;
}

export interface CleanupOptions {
  indices?: string[];
  olderThan: string;
}

/**
 * üìä SearchIndexService - Gestion des indices Elasticsearch
 * 
 * Service pour la gestion compl√®te des indices :
 * ‚úÖ Cr√©ation et configuration des indices
 * ‚úÖ R√©indexation intelligente par batch
 * ‚úÖ Mapping automatique des sch√©mas
 * ‚úÖ Synonymes et analyseurs personnalis√©s
 * ‚úÖ Monitoring et statistiques
 * ‚úÖ Nettoyage et optimisation
 */
@Injectable()
export class SearchIndexService {
  private readonly logger = new Logger(SearchIndexService.name);

  constructor(
    private readonly elasticsearch: ElasticsearchService,
    private readonly config: ConfigService,
  ) {}

  /**
   * üöÄ Initialisation de tous les indices
   */
  async initializeIndices(): Promise<void> {
    this.logger.log('üöÄ Initialisation des indices de recherche...');

    const indices = ['vehicles', 'products', 'pages'];
    
    for (const index of indices) {
      await this.createIndexIfNotExists(index);
    }

    this.logger.log('‚úÖ Tous les indices sont initialis√©s');
  }

  /**
   * üìä Statistiques des indices
   */
  async getIndexStats(): Promise<IndexStats> {
    try {
      const response = await this.elasticsearch.cat.indices({
        index: '*',
        format: 'json',
        h: 'index,docs.count,store.size,creation.date.string',
      });

      const indices = response.body
        .filter((index: any) => !index.index.startsWith('.'))
        .map((index: any) => ({
          name: index.index,
          documents: parseInt(index['docs.count'] || '0'),
          size: index['store.size'] || '0b',
          lastUpdated: index['creation.date.string'] || 'Unknown',
        }));

      const totalDocuments = indices.reduce(
        (sum, index) => sum + index.documents,
        0,
      );

      return {
        totalDocuments,
        totalSize: await this.getTotalSize(),
        indices,
      };
    } catch (error) {
      this.logger.error('‚ùå Erreur r√©cup√©ration stats indices:', error);
      return {
        totalDocuments: 0,
        totalSize: '0b',
        indices: [],
      };
    }
  }

  /**
   * üîÑ R√©indexation intelligente
   */
  async reindexData(options: ReindexOptions): Promise<any> {
    const { index, batchSize, force } = options;
    
    this.logger.log(`üîÑ R√©indexation ${index} (batch: ${batchSize})`);

    try {
      // V√©rifier si l'indice existe
      const exists = await this.elasticsearch.indices.exists({ index });
      
      if (!exists.body && !force) {
        throw new Error(`L'indice ${index} n'existe pas`);
      }

      // Cr√©er un nouvel indice temporaire
      const tempIndex = `${index}_reindex_${Date.now()}`;
      await this.createIndex(tempIndex, this.getIndexMapping(index));

      // R√©indexation par batch
      let processed = 0;
      let hasMore = true;
      
      while (hasMore) {
        const response = await this.elasticsearch.reindex({
          body: {
            source: {
              index,
              size: batchSize,
            },
            dest: {
              index: tempIndex,
            },
          },
          waitForCompletion: true,
        });

        processed += response.body.created || 0;
        hasMore = response.body.batches > 1;
        
        this.logger.log(`üìä R√©index√©: ${processed} documents`);
      }

      // Swap des indices (alias)
      await this.swapIndices(index, tempIndex);
      
      this.logger.log(`‚úÖ R√©indexation ${index} termin√©e: ${processed} documents`);
      
      return {
        index,
        documentsProcessed: processed,
        success: true,
      };

    } catch (error) {
      this.logger.error(`‚ùå Erreur r√©indexation ${index}:`, error);
      throw error;
    }
  }

  /**
   * üèóÔ∏è Cr√©ation d'un indice avec mapping
   */
  async createIndexIfNotExists(indexName: string): Promise<void> {
    try {
      const exists = await this.elasticsearch.indices.exists({
        index: indexName,
      });

      if (!exists.body) {
        await this.createIndex(indexName, this.getIndexMapping(indexName));
        this.logger.log(`‚úÖ Indice cr√©√©: ${indexName}`);
      } else {
        this.logger.log(`‚ÑπÔ∏è Indice existe d√©j√†: ${indexName}`);
      }
    } catch (error) {
      this.logger.error(`‚ùå Erreur cr√©ation indice ${indexName}:`, error);
      throw error;
    }
  }

  /**
   * üó∫Ô∏è Configuration des mappings par type d'indice
   */
  private getIndexMapping(indexName: string): any {
    const commonMapping = {
      settings: {
        analysis: {
          analyzer: {
            french_analyzer: {
              tokenizer: 'standard',
              filter: [
                'lowercase',
                'french_elision',
                'french_stop',
                'french_stemmer',
                'asciifolding',
              ],
            },
          },
          filter: {
            french_elision: {
              type: 'elision',
              articles: ['l', 'm', 't', 'qu', 'n', 's', 'j', 'd'],
            },
            french_stop: {
              type: 'stop',
              stopwords: '_french_',
            },
            french_stemmer: {
              type: 'stemmer',
              language: 'light_french',
            },
          },
        },
        'index.max_result_window': 50000,
      },
    };

    switch (indexName) {
      case 'vehicles':
        return {
          ...commonMapping,
          mappings: {
            properties: {
              brand: {
                type: 'text',
                analyzer: 'french_analyzer',
                fields: {
                  keyword: { type: 'keyword' },
                },
              },
              model: {
                type: 'text',
                analyzer: 'french_analyzer',
                fields: {
                  keyword: { type: 'keyword' },
                },
              },
              full_name: {
                type: 'text',
                analyzer: 'french_analyzer',
              },
              description: {
                type: 'text',
                analyzer: 'french_analyzer',
              },
              year: { type: 'integer' },
              price: { type: 'integer' },
              mileage: { type: 'integer' },
              fuel: {
                type: 'text',
                fields: { keyword: { type: 'keyword' } },
              },
              transmission: {
                type: 'text',
                fields: { keyword: { type: 'keyword' } },
              },
              body_type: {
                type: 'text',
                fields: { keyword: { type: 'keyword' } },
              },
              availability: {
                type: 'keyword',
              },
              features: {
                type: 'text',
                analyzer: 'french_analyzer',
              },
              images: { type: 'keyword' },
              dealer: {
                type: 'object',
                properties: {
                  name: { type: 'text' },
                  location: { type: 'geo_point' },
                  rating: { type: 'float' },
                },
              },
              created_at: { type: 'date' },
              updated_at: { type: 'date' },
            },
          },
        };

      case 'products':
        return {
          ...commonMapping,
          mappings: {
            properties: {
              title: {
                type: 'text',
                analyzer: 'french_analyzer',
              },
              description: {
                type: 'text',
                analyzer: 'french_analyzer',
              },
              category: {
                type: 'text',
                fields: { keyword: { type: 'keyword' } },
              },
              price: { type: 'float' },
              brand: {
                type: 'text',
                fields: { keyword: { type: 'keyword' } },
              },
              sku: { type: 'keyword' },
              availability: { type: 'boolean' },
              tags: { type: 'keyword' },
              created_at: { type: 'date' },
            },
          },
        };

      case 'pages':
        return {
          ...commonMapping,
          mappings: {
            properties: {
              title: {
                type: 'text',
                analyzer: 'french_analyzer',
                boost: 2.0,
              },
              content: {
                type: 'text',
                analyzer: 'french_analyzer',
              },
              url: { type: 'keyword' },
              meta_description: {
                type: 'text',
                analyzer: 'french_analyzer',
              },
              keywords: { type: 'keyword' },
              category: { type: 'keyword' },
              last_modified: { type: 'date' },
              word_count: { type: 'integer' },
            },
          },
        };

      default:
        return commonMapping;
    }
  }

  /**
   * üîß Gestion des synonymes
   */
  async getSynonyms(): Promise<string[]> {
    try {
      // R√©cup√©rer les synonymes depuis la configuration de l'analyzeur
      const response = await this.elasticsearch.indices.getSettings({
        index: 'vehicles',
      });

      // Extraire les synonymes si configur√©s
      const settings = response.body.vehicles?.settings;
      const synonyms = settings?.index?.analysis?.filter?.synonym_filter?.synonyms || [];
      
      return synonyms;
    } catch (error) {
      this.logger.error('‚ùå Erreur r√©cup√©ration synonymes:', error);
      return [];
    }
  }

  async updateSynonyms(synonyms: string[]): Promise<void> {
    try {
      this.logger.log('üîß Mise √† jour des synonymes...');

      // Fermer l'indice pour modification
      await this.elasticsearch.indices.close({ index: 'vehicles' });

      // Mettre √† jour les settings avec les nouveaux synonymes
      await this.elasticsearch.indices.putSettings({
        index: 'vehicles',
        body: {
          analysis: {
            filter: {
              synonym_filter: {
                type: 'synonym',
                synonyms,
              },
            },
          },
        },
      });

      // Rouvrir l'indice
      await this.elasticsearch.indices.open({ index: 'vehicles' });

      this.logger.log(`‚úÖ Synonymes mis √† jour: ${synonyms.length} entr√©es`);
    } catch (error) {
      this.logger.error('‚ùå Erreur mise √† jour synonymes:', error);
      throw error;
    }
  }

  /**
   * üßπ Nettoyage des anciens indices
   */
  async cleanupOldIndices(options: CleanupOptions): Promise<any> {
    try {
      this.logger.log('üßπ Nettoyage des anciens indices...');

      const response = await this.elasticsearch.cat.indices({
        format: 'json',
        h: 'index,creation.date',
      });

      const cutoffDate = this.calculateCutoffDate(options.olderThan);
      const indicesToDelete = response.body
        .filter((index: any) => {
          if (options.indices && !options.indices.includes(index.index)) {
            return false;
          }
          
          const creationDate = new Date(parseInt(index['creation.date']));
          return creationDate < cutoffDate;
        })
        .map((index: any) => index.index);

      let deletedCount = 0;
      for (const index of indicesToDelete) {
        try {
          await this.elasticsearch.indices.delete({ index });
          deletedCount++;
          this.logger.log(`üóëÔ∏è Indice supprim√©: ${index}`);
        } catch (error) {
          this.logger.warn(`‚ö†Ô∏è Impossible de supprimer ${index}:`, error.message);
        }
      }

      return {
        deletedIndices: indicesToDelete,
        deletedCount,
      };
    } catch (error) {
      this.logger.error('‚ùå Erreur nettoyage indices:', error);
      throw error;
    }
  }

  /**
   * üè• V√©rification de sant√©
   */
  async isHealthy(): Promise<boolean> {
    try {
      const response = await this.elasticsearch.cluster.health({
        timeout: '5s',
      });

      return response.body.status === 'green' || response.body.status === 'yellow';
    } catch (error) {
      this.logger.error('‚ùå Health check ES failed:', error);
      return false;
    }
  }

  async checkIndicesHealth(): Promise<Record<string, boolean>> {
    const indices = ['vehicles', 'products', 'pages'];
    const health: Record<string, boolean> = {};

    for (const index of indices) {
      try {
        const exists = await this.elasticsearch.indices.exists({ index });
        health[index] = exists.body;
      } catch (error) {
        health[index] = false;
      }
    }

    return health;
  }

  // M√©thodes priv√©es

  private async createIndex(indexName: string, config: any): Promise<void> {
    await this.elasticsearch.indices.create({
      index: indexName,
      body: config,
    });
  }

  private async swapIndices(currentIndex: string, newIndex: string): Promise<void> {
    const aliasName = `${currentIndex}_current`;
    
    try {
      // Supprimer l'ancien alias s'il existe
      await this.elasticsearch.indices.deleteAlias({
        index: currentIndex,
        name: aliasName,
      }).catch(() => {
        // Ignore si l'alias n'existe pas
      });

      // Cr√©er le nouvel alias
      await this.elasticsearch.indices.putAlias({
        index: newIndex,
        name: aliasName,
      });

      // Supprimer l'ancien indice apr√®s un d√©lai de s√©curit√©
      setTimeout(async () => {
        try {
          await this.elasticsearch.indices.delete({ index: currentIndex });
          this.logger.log(`üóëÔ∏è Ancien indice supprim√©: ${currentIndex}`);
        } catch (error) {
          this.logger.warn(`‚ö†Ô∏è Impossible de supprimer l'ancien indice:`, error.message);
        }
      }, 60000); // 1 minute de d√©lai

    } catch (error) {
      this.logger.error('‚ùå Erreur swap indices:', error);
      throw error;
    }
  }

  private async getTotalSize(): Promise<string> {
    try {
      const response = await this.elasticsearch.cat.allocation({
        format: 'json',
        h: 'disk.used',
      });

      const totalBytes = response.body.reduce(
        (sum: number, node: any) => sum + this.parseSize(node['disk.used']),
        0,
      );

      return this.formatBytes(totalBytes);
    } catch (error) {
      return '0b';
    }
  }

  private parseSize(sizeStr: string): number {
    // Parse tailles comme "1.2gb", "500mb", etc.
    const units = { b: 1, kb: 1024, mb: 1024**2, gb: 1024**3, tb: 1024**4 };
    const match = sizeStr.toLowerCase().match(/^(\d+\.?\d*)(b|kb|mb|gb|tb)$/);
    
    if (!match) return 0;
    
    const value = parseFloat(match[1]);
    const unit = match[2] as keyof typeof units;
    
    return value * units[unit];
  }

  private formatBytes(bytes: number): string {
    if (bytes === 0) return '0b';
    
    const k = 1024;
    const sizes = ['b', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + sizes[i];
  }

  private calculateCutoffDate(olderThan: string): Date {
    const now = new Date();
    const match = olderThan.match(/^(\d+)(d|h|m)$/);
    
    if (!match) {
      throw new Error('Format invalide pour olderThan (ex: 30d, 24h, 60m)');
    }
    
    const value = parseInt(match[1]);
    const unit = match[2];
    
    switch (unit) {
      case 'd':
        return new Date(now.getTime() - value * 24 * 60 * 60 * 1000);
      case 'h':
        return new Date(now.getTime() - value * 60 * 60 * 1000);
      case 'm':
        return new Date(now.getTime() - value * 60 * 1000);
      default:
        return new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000); // 30 days par d√©faut
    }
  }
}
