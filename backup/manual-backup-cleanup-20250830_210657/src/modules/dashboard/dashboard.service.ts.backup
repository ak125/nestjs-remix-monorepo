import { Injectable, Logger } from '@nestjs/common';import { SupabaseBaseService } from '../../database/services/supabase-base.service';@Injectable()export class DashboardService extends SupabaseBaseService {  protected readonly logger = new Logger(DashboardService.name);  /**   * üéØ Service de tableau de bord g√©n√©rique et modulaire   * Combinaison du meilleur : Architecture moderne existante + Flexibilit√© modulaire   */  async getDashboardData(module: string, userId: string) {    try {      this.logger.log(        `Fetching dashboard data for module: ${module}, user: ${userId}`,      );      // R√©cup√©rer la configuration du dashboard (si elle existe)      const config = await this.getDashboardConfig(module, userId);      // Charger les donn√©es des widgets selon le module      const widgetData = await this.loadModuleWidgets(module);      return {        module,        config,        data: widgetData,        timestamp: new Date().toISOString(),        success: true,      };    } catch (error) {      this.logger.error(        `Error in getDashboardData for module ${module}:`,        error,      );      return {        module,        config: this.getDefaultConfig(module),        data: {},        timestamp: new Date().toISOString(),        success: false,        error: error instanceof Error ? error.message : 'Unknown error',      };    }  }  /**   * üìä Dashboard commercial sp√©cifique - Utilise les m√©thodes existantes optimis√©es   */  async getCommercialDashboard(userId: string) {    try {      this.logger.log(`Fetching commercial dashboard for user: ${userId}`);      const [orders, users, suppliers] = await Promise.all([        this.getOrdersStats(),        this.getUsersStats(),        this.getSuppliersStats(),      ]);      return {        module: 'commercial',        widgets: {          orders,          users,          suppliers,        },        lastUpdate: new Date().toISOString(),        success: true,      };    } catch (error) {      this.logger.error('Error in getCommercialDashboard:', error);      return {        module: 'commercial',        widgets: {},        lastUpdate: new Date().toISOString(),        success: false,        error: error instanceof Error ? error.message : 'Unknown error',      };    }  }  /**   * üöö Dashboard exp√©dition sp√©cifique   */  async getExpeditionDashboard(userId: string) {    try {      this.logger.log(`Fetching expedition dashboard for user: ${userId}`);      const [pending, inProgress, shipped, returns] = await Promise.all([        this.getPendingShipments(),        this.getInProgressShipments(),        this.getShippedToday(),        this.getReturnsStats(),      ]);      return {        module: 'expedition',        widgets: {          pending,          inProgress,          shipped,          returns,        },        lastUpdate: new Date().toISOString(),        success: true,      };    } catch (error) {      this.logger.error('Error in getExpeditionDashboard:', error);      return {        module: 'expedition',        widgets: {},        lastUpdate: new Date().toISOString(),        success: false,        error: error instanceof Error ? error.message : 'Unknown error',      };    }  }  /**   * üéØ Dashboard SEO sp√©cifique - Utilise tables existantes   */  async getSeoDashboard(userId: string) {    try {      this.logger.log(`Fetching SEO dashboard for user: ${userId}`);      const [pages, rankings, errors, indexing] = await Promise.all([        this.getPagesStats(),        this.getRankingsStats(),        this.getErrorsStats(),        this.getIndexingStats(),      ]);      return {        module: 'seo',        widgets: {          pages,          rankings,          errors,          indexing,        },        lastUpdate: new Date().toISOString(),        success: true,      };    } catch (error) {      this.logger.error('Error in getSeoDashboard:', error);      return {        module: 'seo',        widgets: {},        lastUpdate: new Date().toISOString(),        success: false,        error: error instanceof Error ? error.message : 'Unknown error',      };    }  }  /**   * üë• Dashboard Staff sp√©cifique   */  async getStaffDashboard(userId: string) {    try {      this.logger.log(`Fetching staff dashboard for user: ${userId}`);      const [members, permissions, activities, performance] = await Promise.all([        this.getStaffMembers(),        this.getPermissionsOverview(),        this.getRecentActivities(),        this.getPerformanceMetrics(),      ]);      return {        module: 'staff',        widgets: {          members,          permissions,          activities,          performance,        },        lastUpdate: new Date().toISOString(),        success: true,      };    } catch (error) {      this.logger.error('Error in getStaffDashboard:', error);      return {        module: 'staff',        widgets: {},        lastUpdate: new Date().toISOString(),        success: false,        error: error instanceof Error ? error.message : 'Unknown error',      };    }  }  // üìä M√©thodes existantes optimis√©es pr√©serv√©es  async getOrdersStats(): Promise<{    totalOrders: number;    completedOrders: number;    pendingOrders: number;    totalRevenue: number;  }> {    try {      this.logger.log('Fetching orders statistics from ___xtr_order');      // R√©cup√©rer le total des commandes      const { count: totalOrders, error: countError } = await this.supabase        .from('___xtr_order')        .select('*', { count: 'exact', head: true });      if (countError) {        this.logger.error('Error counting orders:', countError);        throw countError;      }      // R√©cup√©rer les statistiques d√©taill√©es      const { data: ordersData, error: dataError } = await this.supabase        .from('___xtr_order')        .select('ord_is_pay, ord_total_ttc');      if (dataError) {        this.logger.error('Error fetching orders data:', dataError);        throw dataError;      }      const completedOrders =        ordersData?.filter((order) => order.ord_is_pay === '1').length || 0;      const pendingOrders = (totalOrders || 0) - completedOrders;      const totalRevenue =        ordersData?.reduce((sum, order) => {          if (order.ord_is_pay === '1') {            return sum + parseFloat(order.ord_total_ttc || '0');          }          return sum;        }, 0) || 0;      const stats = {        totalOrders: totalOrders || 0,        completedOrders,        pendingOrders,        totalRevenue,      };      this.logger.log('Orders statistics:', stats);      return stats;    } catch (error) {      this.logger.error('Error in getOrdersStats:', error);      return {        totalOrders: 0,        completedOrders: 0,        pendingOrders: 0,        totalRevenue: 0,      };    }  }  async getUsersStats(): Promise<{    totalUsers: number;    activeUsers: number;  }> {    try {      this.logger.log('Fetching users statistics');      const { count: totalUsers, error: totalError } = await this.supabase        .from('___xtr_customer')        .select('*', { count: 'exact', head: true });      if (totalError) {        this.logger.error('Error counting users:', totalError);        throw totalError;      }      const { count: activeUsers, error: activeError } = await this.supabase        .from('___xtr_customer')        .select('*', { count: 'exact', head: true })        .eq('cst_activ', '1');      if (activeError) {        this.logger.error('Error counting active users:', activeError);        throw activeError;      }      const stats = {        totalUsers: totalUsers || 0,        activeUsers: activeUsers || 0,      };      this.logger.log('Users statistics:', stats);      return stats;    } catch (error) {      this.logger.error('Error in getUsersStats:', error);      return {        totalUsers: 0,        activeUsers: 0,      };    }  }  async getSuppliersStats(): Promise<{ totalSuppliers: number }> {    try {      this.logger.log('Fetching suppliers statistics');      const { count: totalSuppliers, error } = await this.supabase        .from('___xtr_supplier_link_pm')        .select('*', { count: 'exact', head: true });      if (error) {        this.logger.error('Error counting suppliers:', error);        throw error;      }      const stats = { totalSuppliers: totalSuppliers || 0 };      this.logger.log('Suppliers statistics:', stats);      return stats;    } catch (error) {      this.logger.error('Error in getSuppliersStats:', error);      return { totalSuppliers: 0 };    }  }  // üîß M√©thodes helper pour l'architecture modulaire  /**   * Configuration du dashboard par module   */  private async getDashboardConfig(module: string, userId: string) {    try {      // R√©cup√©rer config utilisateur sp√©cifique (si table existe)      const { data: userConfig } = await this.supabase        .from('dashboard_configs')        .select('*')        .eq('module', module)        .eq('user_id', userId)        .single();      return userConfig || this.getDefaultConfig(module);    } catch (error) {      // Si pas de config ou erreur, utiliser config par d√©faut      return this.getDefaultConfig(module);    }  }  /**   * Configuration par d√©faut pour chaque module   */  private getDefaultConfig(module: string) {    const configs: Record<string, any> = {      commercial: {        widgets: ['orders', 'users', 'suppliers'],        layout: { columns: 2, refreshInterval: 30000 },        permissions: ['read'],      },      expedition: {        widgets: ['pending', 'inProgress', 'shipped', 'returns'],        layout: { columns: 2, refreshInterval: 15000 },        permissions: ['read'],      },      seo: {        widgets: ['pages', 'rankings', 'errors', 'indexing'],        layout: { columns: 2, refreshInterval: 60000 },        permissions: ['read'],      },      staff: {        widgets: ['members', 'permissions', 'activities', 'performance'],        layout: { columns: 2, refreshInterval: 45000 },        permissions: ['read', 'write'],      },    };    return configs[module] || { widgets: [], layout: { columns: 1 } };  }  /**   * Charger les donn√©es des widgets selon le module   */  private async loadModuleWidgets(module: string) {    try {      switch (module) {        case 'commercial':          return await this.getCommercialDashboard('system');        case 'expedition':          return await this.getExpeditionDashboard('system');        case 'seo':          return await this.getSeoDashboard('system');        case 'staff':          return await this.getStaffDashboard('system');        default:          return {};      }    } catch (error) {      this.logger.error(`Error loading widgets for module ${module}:`, error);      return {};    }  }  // üöö M√©thodes sp√©cifiques Exp√©dition utilisant tables existantes  private async getPendingShipments() {    try {      const { count } = await this.supabase        .from('___xtr_order')        .select('*', { count: 'exact', head: true })        .eq('ord_status', 2); // Status en attente d'exp√©dition      return { count: count || 0, status: 'pending' };    } catch (error) {      this.logger.error('Error in getPendingShipments:', error);      return { count: 0, status: 'error' };    }  }  private async getInProgressShipments() {    try {      const { count } = await this.supabase        .from('___xtr_order')        .select('*', { count: 'exact', head: true })        .in('ord_status', [3, 4]); // En pr√©paration, pr√™t √† exp√©dier      return { count: count || 0, status: 'inProgress' };    } catch (error) {      this.logger.error('Error in getInProgressShipments:', error);      return { count: 0, status: 'error' };    }  }  private async getShippedToday() {    try {      const today = new Date();      today.setHours(0, 0, 0, 0);      const { count } = await this.supabase        .from('___xtr_order')        .select('*', { count: 'exact', head: true })        .eq('ord_status', 5) // Exp√©di√©        .gte('ord_date_livraison', today.toISOString());      return { count: count || 0, date: today.toISOString() };    } catch (error) {      this.logger.error('Error in getShippedToday:', error);      return { count: 0, date: new Date().toISOString() };    }  }  private async getReturnsStats() {    try {      const { count } = await this.supabase        .from('___xtr_order')        .select('*', { count: 'exact', head: true })        .in('ord_status', [91, 92]); // Retours/Annulations      return { count: count || 0, type: 'returns' };    } catch (error) {      this.logger.error('Error in getReturnsStats:', error);      return { count: 0, type: 'error' };    }  }  // üéØ M√©thodes sp√©cifiques SEO utilisant tables existantes  private async getPagesStats() {    try {      const { count: total } = await this.supabase        .from('___META_TAGS_ARIANE')        .select('*', { count: 'exact', head: true });      const { count: optimized } = await this.supabase        .from('___META_TAGS_ARIANE')        .select('*', { count: 'exact', head: true })        .not('meta_title', 'is', null)        .not('meta_description', 'is', null);      return {        total: total || 0,        optimized: optimized || 0,        percentage: total ? Math.round(((optimized || 0) / total) * 100) : 0,        source: '___META_TAGS_ARIANE',      };    } catch (error) {      this.logger.error('Error in getPagesStats:', error);      return { total: 0, optimized: 0, percentage: 0, source: 'error' };    }  }  private async getRankingsStats() {    try {      // Utiliser une vraie table si disponible, sinon donn√©es par d√©faut      return {        keywords_tracked: 150,        top_10: 45,        top_20: 78,        improvement: '+12%',        source: 'simulated', // Indiquer que c'est simul√©      };    } catch (error) {      this.logger.error('Error in getRankingsStats:', error);      return {        keywords_tracked: 0,        top_10: 0,        top_20: 0,        improvement: 'N/A',        source: 'error',      };    }  }  private async getErrorsStats() {    try {      const yesterday = new Date();      yesterday.setDate(yesterday.getDate() - 1);      // Essayer d'utiliser une vraie table error_logs si elle existe      const { count } = await this.supabase        .from('error_logs')        .select('*', { count: 'exact', head: true })        .gte('created_at', yesterday.toISOString());      return {        last_24h: count || 0,        critical: 0,        source: 'error_logs',      };    } catch (error) {      // Si table n'existe pas, retourner des donn√©es par d√©faut      this.logger.log('Table error_logs not found, using default data');      return {        last_24h: 0,        critical: 0,        source: 'default',      };    }  }  private async getIndexingStats() {    try {      return {        indexed_pages: 1250,        crawl_errors: 3,        last_crawl: new Date().toISOString(),        source: 'simulated',      };    } catch (error) {      this.logger.error('Error in getIndexingStats:', error);      return {        indexed_pages: 0,        crawl_errors: 0,        last_crawl: new Date().toISOString(),        source: 'error',      };    }  }  // üë• M√©thodes sp√©cifiques Staff  private async getStaffMembers() {    try {      // Utiliser table users/staff existante      const { count } = await this.supabase        .from('___xtr_customer')        .select('*', { count: 'exact', head: true })        .eq('cst_activ', '1');      return {        active: count || 0,        source: '___xtr_customer',      };    } catch (error) {      this.logger.error('Error in getStaffMembers:', error);      return { active: 0, source: 'error' };    }  }  private async getPermissionsOverview() {    try {      const { data } = await this.supabase        .from('module_permissions')        .select('module, role, can_access');      const modules = [...new Set(data?.map((p) => p.module) || [])];      return {        total_rules: data?.length || 0,        modules: modules.length,        module_list: modules,      };    } catch (error) {      this.logger.log('Table module_permissions not found, using default data');      return {        total_rules: 0,        modules: 4, // Commercial, Expedition, SEO, Staff        module_list: ['commercial', 'expedition', 'seo', 'staff'],      };    }  }  private async getRecentActivities() {    try {      const { data } = await this.supabase        .from('access_logs')        .select('*')        .order('created_at', { ascending: false })        .limit(10);      return data || [];    } catch (error) {      this.logger.log('Table access_logs not found, using default data');      return [        {          id: '1',          action: 'Dashboard Access',          module: 'commercial',          timestamp: new Date().toISOString(),          user: 'system',        },      ];    }  }  private async getPerformanceMetrics() {    try {      return {        response_time: '120ms',        uptime: '99.9%',        requests_today: 15420,        source: 'simulated',      };    } catch (error) {      this.logger.error('Error in getPerformanceMetrics:', error);      return {        response_time: 'N/A',        uptime: 'N/A',        requests_today: 0,        source: 'error',      };    }  }  /**   * Dashboard test endpoint   */  async getTestData(): Promise<{    success: boolean;    message: string;    timestamp: string;  }> {    return {      success: true,      message:        'DashboardService modernized - Architecture existante + Flexibilit√© modulaire',      timestamp: new Date().toISOString(),    };  }}