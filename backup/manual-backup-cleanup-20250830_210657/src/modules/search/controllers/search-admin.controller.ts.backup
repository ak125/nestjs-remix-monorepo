import { Controller, Get, Post, Put, Delete, Query, Body, Logger, UseGuards } from '@nestjs/common';
import { SearchIndexService } from '../services/search-index.service';
import { SearchAnalyticsService } from '../services/search-analytics.service';
import { SearchCacheService } from '../services/search-cache.service';
// import { AdminGuard } from '../../auth/guards/admin.guard';

export interface IndexStats {
  totalDocuments: number;
  totalSize: string;
  indices: {
    name: string;
    documents: number;
    size: string;
    lastUpdated: string;
  }[];
}

export interface ReindexRequest {
  index: string;
  batchSize?: number;
  force?: boolean;
}

/**
 * 🛠️ SearchAdminController - Interface d'administration pour la recherche
 * 
 * Contrôleur pour les opérations administratives :
 * ✅ Gestion des indices Elasticsearch
 * ✅ Réindexation et maintenance
 * ✅ Monitoring et métriques
 * ✅ Gestion du cache
 * ✅ Configuration des synonymes
 * ✅ Tests de performance
 */
@Controller('api/admin/search')
// @UseGuards(AdminGuard) // À décommenter quand le guard admin sera créé
export class SearchAdminController {
  private readonly logger = new Logger(SearchAdminController.name);

  constructor(
    private readonly indexService: SearchIndexService,
    private readonly analytics: SearchAnalyticsService,
    private readonly cache: SearchCacheService,
  ) {}

  /**
   * 📊 Tableau de bord des métriques de recherche
   */
  @Get('dashboard')
  async getDashboard() {
    try {
      this.logger.log('📊 Génération dashboard admin recherche');

      const [indexStats, cacheStats, searchMetrics, topQueries] = await Promise.all([
        this.indexService.getIndexStats(),
        this.cache.getStats(),
        this.analytics.getSearchMetrics(),
        this.analytics.getTopQueries(20),
      ]);

      return {
        success: true,
        data: {
          indices: indexStats,
          cache: cacheStats,
          search: searchMetrics,
          popularQueries: topQueries,
          timestamp: new Date().toISOString(),
        },
      };
    } catch (error) {
      this.logger.error('❌ Erreur dashboard admin:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * 📈 Statistiques détaillées des indices
   */
  @Get('indices/stats')
  async getIndexStats(): Promise<{ success: boolean; data?: IndexStats; error?: string }> {
    try {
      const stats = await this.indexService.getIndexStats();
      return {
        success: true,
        data: stats,
      };
    } catch (error) {
      this.logger.error('❌ Erreur stats indices:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * 🔄 Réindexation complète ou partielle
   */
  @Post('reindex')
  async reindex(@Body() request: ReindexRequest) {
    try {
      this.logger.log(`🔄 Démarrage réindexation: ${request.index}`);

      const result = await this.indexService.reindexData({
        index: request.index,
        batchSize: request.batchSize || 1000,
        force: request.force || false,
      });

      this.logger.log(`✅ Réindexation terminée: ${request.index}`);

      return {
        success: true,
        data: result,
        message: `Réindexation de ${request.index} terminée avec succès`,
      };
    } catch (error) {
      this.logger.error(`❌ Erreur réindexation ${request.index}:`, error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * 🧹 Nettoyage des indices
   */
  @Post('indices/cleanup')
  async cleanupIndices(@Body() body: { indices?: string[]; olderThan?: string }) {
    try {
      this.logger.log('🧹 Démarrage nettoyage indices');

      const result = await this.indexService.cleanupOldIndices({
        indices: body.indices,
        olderThan: body.olderThan || '30d',
      });

      return {
        success: true,
        data: result,
        message: 'Nettoyage des indices terminé',
      };
    } catch (error) {
      this.logger.error('❌ Erreur nettoyage indices:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * 🏷️ Gestion du cache
   */
  @Get('cache/stats')
  async getCacheStats() {
    try {
      const stats = await this.cache.getStats();
      return {
        success: true,
        data: stats,
      };
    } catch (error) {
      this.logger.error('❌ Erreur stats cache:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  @Post('cache/clear')
  async clearCache(@Body() body: { pattern?: string; tag?: string }) {
    try {
      this.logger.log(`🗑️ Nettoyage cache: ${body.pattern || body.tag || 'all'}`);

      if (body.tag) {
        await this.cache.invalidateByTag(body.tag);
      } else {
        await this.cache.cleanup();
      }

      return {
        success: true,
        message: 'Cache nettoyé avec succès',
      };
    } catch (error) {
      this.logger.error('❌ Erreur nettoyage cache:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  @Post('cache/warmup')
  async warmupCache() {
    try {
      this.logger.log('🔥 Démarrage warm-up cache');

      await this.cache.preloadPopularSearches();

      return {
        success: true,
        message: 'Warm-up cache terminé',
      };
    } catch (error) {
      this.logger.error('❌ Erreur warm-up cache:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * 📊 Analytics et métriques
   */
  @Get('analytics/overview')
  async getAnalyticsOverview(@Query('days') days: number = 7) {
    try {
      const overview = await this.analytics.getOverview(days);
      return {
        success: true,
        data: overview,
      };
    } catch (error) {
      this.logger.error('❌ Erreur analytics overview:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  @Get('analytics/queries/top')
  async getTopQueries(@Query('limit') limit: number = 50, @Query('days') days: number = 7) {
    try {
      const topQueries = await this.analytics.getTopQueries(limit, days);
      return {
        success: true,
        data: topQueries,
      };
    } catch (error) {
      this.logger.error('❌ Erreur top queries:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  @Get('analytics/queries/failed')
  async getFailedQueries(@Query('limit') limit: number = 50, @Query('days') days: number = 7) {
    try {
      const failedQueries = await this.analytics.getFailedQueries(limit, days);
      return {
        success: true,
        data: failedQueries,
      };
    } catch (error) {
      this.logger.error('❌ Erreur failed queries:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * 🔧 Configuration des synonymes
   */
  @Get('synonyms')
  async getSynonyms() {
    try {
      const synonyms = await this.indexService.getSynonyms();
      return {
        success: true,
        data: synonyms,
      };
    } catch (error) {
      this.logger.error('❌ Erreur récupération synonymes:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  @Put('synonyms')
  async updateSynonyms(@Body() body: { synonyms: string[] }) {
    try {
      this.logger.log('🔧 Mise à jour synonymes');

      await this.indexService.updateSynonyms(body.synonyms);

      return {
        success: true,
        message: 'Synonymes mis à jour avec succès',
      };
    } catch (error) {
      this.logger.error('❌ Erreur mise à jour synonymes:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * 🧪 Tests de performance
   */
  @Post('performance/test')
  async runPerformanceTest(@Body() body: { queries?: string[]; concurrent?: number }) {
    try {
      this.logger.log('🧪 Démarrage test de performance');

      const testQueries = body.queries || [
        'peugeot 308',
        'renault clio diesel',
        'volkswagen golf 2020',
        'citroën c3 essence',
        'voiture occasion moins 15000',
      ];

      const concurrent = body.concurrent || 10;
      const results = await this.runLoadTest(testQueries, concurrent);

      return {
        success: true,
        data: results,
      };
    } catch (error) {
      this.logger.error('❌ Erreur test performance:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }

  /**
   * 🔍 Test de charge
   */
  private async runLoadTest(queries: string[], concurrent: number): Promise<any> {
    const startTime = Date.now();
    const results = {
      totalQueries: queries.length * concurrent,
      concurrent,
      duration: 0,
      avgResponseTime: 0,
      successRate: 0,
      errors: [] as string[],
    };

    try {
      // Simulation d'un test de charge simple
      // Dans un vrai scénario, on utiliserait les services de recherche
      const promises = [];
      
      for (let i = 0; i < concurrent; i++) {
        for (const query of queries) {
          promises.push(this.simulateSearch(query));
        }
      }

      const responses = await Promise.allSettled(promises);
      
      const successful = responses.filter(r => r.status === 'fulfilled').length;
      const failed = responses.filter(r => r.status === 'rejected');
      
      results.duration = Date.now() - startTime;
      results.avgResponseTime = results.duration / results.totalQueries;
      results.successRate = (successful / results.totalQueries) * 100;
      results.errors = failed.map(f => f.reason?.message || 'Unknown error');

      return results;
    } catch (error) {
      results.errors.push(error.message);
      return results;
    }
  }

  private async simulateSearch(query: string): Promise<void> {
    // Simulation d'une recherche (remplacer par un vrai appel)
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (Math.random() > 0.95) { // 5% d'échec simulé
          reject(new Error(`Simulated error for query: ${query}`));
        } else {
          resolve();
        }
      }, Math.random() * 100 + 50); // 50-150ms de latence simulée
    });
  }

  /**
   * 🔧 Santé du système de recherche
   */
  @Get('health')
  async healthCheck() {
    try {
      const health = {
        elasticsearch: await this.indexService.isHealthy(),
        cache: await this.checkCacheHealth(),
        indices: await this.indexService.checkIndicesHealth(),
        timestamp: new Date().toISOString(),
      };

      const allHealthy = Object.values(health).every(
        (status, index) => index === 3 || status === true // Skip timestamp
      );

      return {
        success: true,
        status: allHealthy ? 'healthy' : 'degraded',
        data: health,
      };
    } catch (error) {
      this.logger.error('❌ Erreur health check:', error);
      return {
        success: false,
        status: 'unhealthy',
        error: error.message,
      };
    }
  }

  private async checkCacheHealth(): Promise<boolean> {
    try {
      // Test simple du cache
      const testKey = 'health-check-test';
      const testValue = { timestamp: Date.now() };
      
      await this.cache.set(testKey, testValue, 10);
      const retrieved = await this.cache.get(testKey);
      await this.cache.del(testKey);
      
      return retrieved !== null;
    } catch (error) {
      return false;
    }
  }
}
