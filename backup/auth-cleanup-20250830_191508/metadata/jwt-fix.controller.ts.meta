Fichier: src/auth/jwt-fix.controller.ts
Cat√©gorie: Contr√¥leur de debug/test
Raison de suppression: Utilis√© uniquement pour le d√©bogage, fonctionnalit√© int√©gr√©e ailleurs
Date de sauvegarde: Sat Aug 30 19:15:08 UTC 2025
Taille: 4820
Checksum MD5: e39a8285fb7ea2f43ea1d904773ac10a  src/auth/jwt-fix.controller.ts
Git commit: fc1abddb0c0469efecef4a9a1c49bc010bd9bae8
Git branch: optimisation

=== CONTENU ===
import { Controller, Get, Post, Body, Headers, UseGuards, Request } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { AuthService } from './auth.service';
import { AuthGuard } from '@nestjs/passport';
import { JwtAuthGuard } from './jwt-auth.guard';

@Controller('jwt-fix')
export class JwtFixController {
  constructor(
    private readonly jwtService: JwtService,
    private readonly authService: AuthService,
  ) {}

  /**
   * GET /jwt-fix/test-simple
   * Test simple sans guard
   */
  @Get('test-simple')
  async testSimple() {
    return {
      success: true,
      message: 'Endpoint simple fonctionnel',
      timestamp: new Date().toISOString(),
    };
  }

  /**
   * GET /jwt-fix/test-with-passport
   * Test avec le m√™me guard que l'endpoint qui plante
   */
    // Test simple sans authentification
  @Get('test-no-auth')
  async testNoAuth() {
    return {
      success: true,
      message: 'Endpoint sans authentification fonctionne',
      timestamp: new Date().toISOString(),
    };
  }

  @Get('test-with-passport')
  @UseGuards(JwtAuthGuard)
  async testWithPassport(@Request() req: any) {
    return {
      success: true,
      message: 'JWT authentication r√©ussie avec Passport',
      user: req.user,
      timestamp: new Date().toISOString(),
    };
  }

  // Test avec AuthGuard direct
  @Get('test-direct-authguard')
  @UseGuards(AuthGuard('jwt'))
  async testDirectAuthGuard(@Request() req: any) {
    return {
      success: true,
      message: 'JWT authentication r√©ussie avec AuthGuard direct',
      user: req.user,
      timestamp: new Date().toISOString(),
    };
  }

  /**
   * POST /jwt-fix/manual-validate
   * Validation manuelle du JWT sans utiliser le guard
   */
  @Post('manual-validate')
  async manualValidate(
    @Headers('authorization') authHeader: string,
    @Body() dto?: { token?: string },
  ) {
    try {
      // Extraire le token
      let token = dto?.token;
      if (!token && authHeader) {
        token = authHeader.replace('Bearer ', '');
      }

      if (!token) {
        return {
          success: false,
          error: 'Token manquant',
        };
      }

      // D√©coder le token
      const decoded = this.jwtService.decode(token);
      console.log('üîç JWT Fix - Token d√©cod√©:', JSON.stringify(decoded, null, 2));

      // V√©rifier le token
      const verified = this.jwtService.verify(token);
      console.log('‚úÖ JWT Fix - Token v√©rifi√©:', JSON.stringify(verified, null, 2));

      // Si c'est un utilisateur test, retourner directement
      if (verified.sub === 'test-user-123') {
        console.log('‚úÖ JWT Fix - Utilisateur test valid√©');
        return {
          success: true,
          user: {
            id: verified.sub,
            email: verified.email,
            firstName: verified.firstName,
            lastName: verified.lastName,
            level: verified.level,
            isAdmin: verified.isAdmin,
            isPro: verified.isPro,
            isActive: verified.isActive,
          },
          message: 'Token valide pour utilisateur test',
        };
      }

      // Pour les vrais utilisateurs, v√©rifier dans la base
      const user = await this.authService.getUserById(verified.sub);
      if (user) {
        return {
          success: true,
          user,
          message: 'Token valide pour utilisateur r√©el',
        };
      } else {
        return {
          success: false,
          error: 'Utilisateur non trouv√©',
        };
      }
    } catch (error) {
      console.error('‚ùå JWT Fix - Erreur:', error);
      return {
        success: false,
        error: `Erreur de validation: ${error.message}`,
      };
    }
  }

  /**
   * POST /jwt-fix/create-working-token
   * Cr√©er un token qui fonctionne √† coup s√ªr
   */
  @Post('create-working-token')
  async createWorkingToken(@Body() dto?: { userId?: string }) {
    try {
      const payload = {
        sub: dto?.userId || 'test-user-123',
        email: 'test@example.com',
        firstName: 'Test',
        lastName: 'User',
        level: 5,
        isAdmin: false,
        isPro: true,
        isActive: true,
      };

      const token = this.jwtService.sign(payload, { expiresIn: '1h' });
      console.log('üîß JWT Fix - Token cr√©√©:', token);

      // V√©rifier imm√©diatement le token
      const verification = this.jwtService.verify(token);
      console.log('‚úÖ JWT Fix - V√©rification imm√©diate:', JSON.stringify(verification, null, 2));

      return {
        success: true,
        token,
        payload,
        verification,
        usage: `curl -H "Authorization: Bearer ${token}" http://localhost:3000/jwt-fix/manual-validate`,
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
      };
    }
  }
}
