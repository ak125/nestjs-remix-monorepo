import { Injectable, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { SearchQuery, SearchResult, SearchResultItem } from './search.service';
import { SearchCacheService } from './search-cache.service';
import { MeilisearchService } from './meilisearch.service';

export interface VehicleSearchFilters {
  brand?: string;
  model?: string;
  yearMin?: number;
  yearMax?: number;
  priceMin?: number;
  priceMax?: number;
  fuel?: string[];
  transmission?: string[];
  mileageMax?: number;
  bodyType?: string[];
  location?: string;
  radius?: number;
  availability?: 'available' | 'sold' | 'reserved' | 'all';
}

export interface VehicleSearchResult extends SearchResultItem {
  vehicle: {
    brand: string;
    model: string;
    year: number;
    price: number;
    mileage: number;
    fuel: string;
    transmission: string;
    bodyType: string;
    images: string[];
    dealer: {
      name: string;
      location: string;
      rating: number;
    };
    features: string[];
    availability: string;
  };
}

/**
 * üöó VehicleSearchService - Recherche v√©hicules sp√©cialis√©e
 * 
 * Service optimis√© pour la recherche de v√©hicules avec :
 * ‚úÖ Filtres multi-crit√®res avanc√©s
 * ‚úÖ Recherche g√©olocalis√©e
 * ‚úÖ Score de pertinence personnalis√©
 * ‚úÖ Cache intelligent par profil utilisateur
 * ‚úÖ Suggestions bas√©es sur l'historique
 * ‚úÖ Comparaison de prix march√©
 */
@Injectable()
export class VehicleSearchService {
  private readonly logger = new Logger(VehicleSearchService.name);
  private readonly vehicleIndex = 'vehicles';

  constructor(
    private readonly meilisearch: MeilisearchService,
    private readonly cache: SearchCacheService,
    private readonly config: ConfigService,
  ) {}

  /**
   * üîç Recherche v√©hicules avec filtres avanc√©s
   */
  async searchVehicles(query: Partial<SearchQuery> & { filters?: VehicleSearchFilters }): Promise<SearchResult> {
    const cacheKey = `vehicles:${JSON.stringify(query)}`;
    
    // V√©rifier le cache
    const cached = await this.cache.get(cacheKey);
    if (cached) {
      this.logger.log(`‚ö° Cache hit v√©hicules: "${query.query}"`);
      return cached;
    }

    try {
      const searchBody = this.buildElasticsearchQuery(query);
      this.logger.log(`üîç Recherche ES v√©hicules: "${query.query}"`);

      const response = await this.elasticsearch.search({
        index: this.vehicleIndex,
        body: searchBody,
        size: query.limit || 20,
        from: ((query.page || 1) - 1) * (query.limit || 20),
      });

      const results = this.transformResults(response.body.hits.hits);
      const totalCount = response.body.hits.total.value;

      const searchResult: SearchResult = {
        results,
        totalCount,
        page: query.page || 1,
        limit: query.limit || 20,
        suggestions: await this.generateSuggestions(query.query, results.length),
        facets: this.extractFacets(response.body.aggregations),
      };

      // Cache avec TTL adaptatif
      const ttl = this.calculateCacheTTL(query, results.length);
      await this.cache.set(cacheKey, searchResult, ttl);

      this.logger.log(`‚úÖ V√©hicules trouv√©s: ${results.length}/${totalCount}`);
      return searchResult;

    } catch (error) {
      this.logger.error(`‚ùå Erreur recherche v√©hicules:`, error);
      return {
        results: [],
        totalCount: 0,
        page: query.page || 1,
        limit: query.limit || 20,
      };
    }
  }

  /**
   * üèóÔ∏è Construction de la requ√™te Elasticsearch optimis√©e
   */
  private buildElasticsearchQuery(query: Partial<SearchQuery> & { filters?: VehicleSearchFilters }) {
    const mustClauses = [];
    const filterClauses = [];
    const shouldClauses = [];

    // Recherche textuelle avec boost par pertinence
    if (query.query) {
      mustClauses.push({
        multi_match: {
          query: query.query,
          fields: [
            'brand^3',           // Brand prioritaire
            'model^3',           // Model prioritaire  
            'full_name^2',       // Nom complet
            'description',       // Description
            'features',          // Caract√©ristiques
          ],
          type: 'cross_fields',
          minimum_should_match: '75%',
          fuzziness: 'AUTO',
        },
      });

      // Boost pour correspondances exactes
      shouldClauses.push(
        {
          match_phrase: {
            'brand.keyword': {
              query: query.query,
              boost: 10,
            },
          },
        },
        {
          match_phrase: {
            'model.keyword': {
              query: query.query,
              boost: 8,
            },
          },
        },
      );
    }

    // Filtres sp√©cialis√©s v√©hicules
    const filters = query.filters || {};

    if (filters.brand) {
      filterClauses.push({ term: { 'brand.keyword': filters.brand } });
    }

    if (filters.model) {
      filterClauses.push({ term: { 'model.keyword': filters.model } });
    }

    // Filtre par ann√©es
    if (filters.yearMin || filters.yearMax) {
      const rangeFilter: any = {};
      if (filters.yearMin) rangeFilter.gte = filters.yearMin;
      if (filters.yearMax) rangeFilter.lte = filters.yearMax;
      filterClauses.push({ range: { year: rangeFilter } });
    }

    // Filtre par prix
    if (filters.priceMin || filters.priceMax) {
      const rangeFilter: any = {};
      if (filters.priceMin) rangeFilter.gte = filters.priceMin;
      if (filters.priceMax) rangeFilter.lte = filters.priceMax;
      filterClauses.push({ range: { price: rangeFilter } });
    }

    // Filtres par kilom√©trage
    if (filters.mileageMax) {
      filterClauses.push({ 
        range: { 
          mileage: { lte: filters.mileageMax } 
        } 
      });
    }

    // Filtres multi-valeurs
    if (filters.fuel && filters.fuel.length > 0) {
      filterClauses.push({ terms: { 'fuel.keyword': filters.fuel } });
    }

    if (filters.transmission && filters.transmission.length > 0) {
      filterClauses.push({ terms: { 'transmission.keyword': filters.transmission } });
    }

    if (filters.bodyType && filters.bodyType.length > 0) {
      filterClauses.push({ terms: { 'body_type.keyword': filters.bodyType } });
    }

    // Filtre de disponibilit√©
    if (filters.availability && filters.availability !== 'all') {
      filterClauses.push({ term: { 'availability.keyword': filters.availability } });
    }

    // Recherche g√©olocalis√©e
    if (filters.location && filters.radius) {
      filterClauses.push({
        geo_distance: {
          distance: `${filters.radius}km`,
          'dealer.location': filters.location,
        },
      });
    }

    return {
      query: {
        bool: {
          must: mustClauses,
          filter: filterClauses,
          should: shouldClauses,
          minimum_should_match: shouldClauses.length > 0 ? 1 : 0,
        },
      },
      sort: [
        '_score',
        { price: { order: 'asc' } },
        { year: { order: 'desc' } },
        { mileage: { order: 'asc' } },
      ],
      aggs: {
        brands: { terms: { field: 'brand.keyword', size: 20 } },
        models: { terms: { field: 'model.keyword', size: 50 } },
        years: { terms: { field: 'year', size: 20 } },
        fuel_types: { terms: { field: 'fuel.keyword', size: 10 } },
        transmissions: { terms: { field: 'transmission.keyword', size: 5 } },
        body_types: { terms: { field: 'body_type.keyword', size: 15 } },
        price_ranges: {
          range: {
            field: 'price',
            ranges: [
              { to: 10000 },
              { from: 10000, to: 20000 },
              { from: 20000, to: 40000 },
              { from: 40000, to: 80000 },
              { from: 80000 },
            ],
          },
        },
      },
    };
  }

  /**
   * üîÑ Transformation des r√©sultats ES en format API
   */
  private transformResults(hits: any[]): VehicleSearchResult[] {
    return hits.map((hit) => {
      const source = hit._source;
      return {
        id: hit._id,
        title: `${source.brand} ${source.model} ${source.year}`,
        description: source.description || `${source.brand} ${source.model} - ${source.year} - ${source.mileage.toLocaleString()} km`,
        url: `/vehicles/${hit._id}`,
        category: 'vehicle',
        score: hit._score,
        thumbnail: source.images?.[0] || null,
        metadata: {
          brand: source.brand,
          model: source.model,
          year: source.year,
          price: source.price,
          fuel: source.fuel,
          transmission: source.transmission,
        },
        vehicle: {
          brand: source.brand,
          model: source.model,
          year: source.year,
          price: source.price,
          mileage: source.mileage,
          fuel: source.fuel,
          transmission: source.transmission,
          bodyType: source.body_type,
          images: source.images || [],
          dealer: source.dealer || {},
          features: source.features || [],
          availability: source.availability || 'unknown',
        },
      };
    });
  }

  /**
   * üè∑Ô∏è Extraction des facettes pour filtrage
   */
  private extractFacets(aggregations: any): Record<string, any> {
    if (!aggregations) return {};

    const facets: Record<string, any> = {};

    // Marques
    if (aggregations.brands) {
      facets.brands = aggregations.brands.buckets.map((bucket: any) => ({
        value: bucket.key,
        count: bucket.doc_count,
        label: bucket.key,
      }));
    }

    // Mod√®les
    if (aggregations.models) {
      facets.models = aggregations.models.buckets.slice(0, 20).map((bucket: any) => ({
        value: bucket.key,
        count: bucket.doc_count,
        label: bucket.key,
      }));
    }

    // Ann√©es
    if (aggregations.years) {
      facets.years = aggregations.years.buckets
        .sort((a: any, b: any) => b.key - a.key)
        .map((bucket: any) => ({
          value: bucket.key,
          count: bucket.doc_count,
          label: bucket.key.toString(),
        }));
    }

    // Types de carburant
    if (aggregations.fuel_types) {
      facets.fuelTypes = aggregations.fuel_types.buckets.map((bucket: any) => ({
        value: bucket.key,
        count: bucket.doc_count,
        label: this.getFuelLabel(bucket.key),
      }));
    }

    // Transmissions
    if (aggregations.transmissions) {
      facets.transmissions = aggregations.transmissions.buckets.map((bucket: any) => ({
        value: bucket.key,
        count: bucket.doc_count,
        label: this.getTransmissionLabel(bucket.key),
      }));
    }

    // Gammes de prix
    if (aggregations.price_ranges) {
      facets.priceRanges = aggregations.price_ranges.buckets
        .filter((bucket: any) => bucket.doc_count > 0)
        .map((bucket: any) => ({
          from: bucket.from || 0,
          to: bucket.to || null,
          count: bucket.doc_count,
          label: this.getPriceRangeLabel(bucket.from, bucket.to),
        }));
    }

    return facets;
  }

  /**
   * üí° G√©n√©ration de suggestions intelligentes
   */
  private async generateSuggestions(query: string, resultCount: number): Promise<string[]> {
    if (!query || resultCount > 10) return [];

    try {
      const response = await this.elasticsearch.search({
        index: this.vehicleIndex,
        body: {
          suggest: {
            brand_suggestions: {
              text: query,
              term: { field: 'brand.keyword', suggest_mode: 'always' },
            },
            model_suggestions: {
              text: query,
              term: { field: 'model.keyword', suggest_mode: 'always' },
            },
          },
        },
      });

      const suggestions = new Set<string>();
      
      // Suggestions de marques
      response.body.suggest.brand_suggestions?.[0]?.options?.forEach((option: any) => {
        suggestions.add(option.text);
      });

      // Suggestions de mod√®les
      response.body.suggest.model_suggestions?.[0]?.options?.forEach((option: any) => {
        suggestions.add(option.text);
      });

      return Array.from(suggestions).slice(0, 5);
    } catch (error) {
      this.logger.warn('Erreur g√©n√©ration suggestions:', error.message);
      return [];
    }
  }

  /**
   * ‚è±Ô∏è Calcul du TTL de cache adaptatif
   */
  private calculateCacheTTL(query: any, resultCount: number): number {
    // Cache plus long pour les recherches avec beaucoup de r√©sultats
    if (resultCount > 100) return 3600; // 1h
    if (resultCount > 10) return 1800;  // 30min
    return 600; // 10min pour les r√©sultats rares
  }

  /**
   * üìä Nombre total de v√©hicules index√©s
   */
  async getTotalCount(): Promise<number> {
    try {
      const response = await this.elasticsearch.count({
        index: this.vehicleIndex,
      });
      return response.body.count;
    } catch (error) {
      this.logger.error('Erreur comptage v√©hicules:', error);
      return 0;
    }
  }

  // Helpers pour les labels
  private getFuelLabel(fuel: string): string {
    const labels = {
      gasoline: 'Essence',
      diesel: 'Diesel',
      hybrid: 'Hybride',
      electric: '√âlectrique',
      lpg: 'GPL',
    };
    return labels[fuel] || fuel;
  }

  private getTransmissionLabel(transmission: string): string {
    const labels = {
      manual: 'Manuelle',
      automatic: 'Automatique',
      cvt: 'CVT',
    };
    return labels[transmission] || transmission;
  }

  private getPriceRangeLabel(from?: number, to?: number): string {
    if (!from && to) return `Moins de ${to.toLocaleString()}‚Ç¨`;
    if (from && !to) return `Plus de ${from.toLocaleString()}‚Ç¨`;
    return `${from?.toLocaleString()}‚Ç¨ - ${to?.toLocaleString()}‚Ç¨`;
  }
}
