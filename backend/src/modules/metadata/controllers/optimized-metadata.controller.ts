/**
 * üìÑ OPTIMIZED METADATA CONTROLLER - Contr√¥leur API M√©tadonn√©es
 * 
 * ‚úÖ API REST pour gestion des m√©tadonn√©es
 * 
 * Endpoints disponibles :
 * ‚úÖ GET  /api/metadata/:path    ‚Üí R√©cup√©rer m√©tadonn√©es
 * ‚úÖ PUT  /api/metadata/:path    ‚Üí Mettre √† jour m√©tadonn√©es
 * ‚úÖ DELETE /api/metadata/:path  ‚Üí Supprimer m√©tadonn√©es
 */

import {
  Controller,
  Get,
  Put,
  Delete,
  Param,
  Body,
  Logger,
  HttpException,
  HttpStatus,
} from '@nestjs/common';
import { 
  OptimizedMetadataService, 
  PageMetadata, 
  MetadataUpdateData 
} from '../services/optimized-metadata.service';

@Controller('api/metadata')
export class OptimizedMetadataController {
  private readonly logger = new Logger(OptimizedMetadataController.name);

  constructor(private readonly metadataService: OptimizedMetadataService) {
    this.logger.log('üìÑ OptimizedMetadataController initialis√©');
  }

  /**
   * R√©cup√©rer les m√©tadonn√©es d'une page
   * GET /api/metadata/:path
   */
  @Get(':path(*)')
  async getMetadata(@Param('path') path: string): Promise<{ success: boolean; data: PageMetadata }> {
    try {
      const decodedPath = path ? '/' + decodeURIComponent(path) : '/';
      
      this.logger.debug(`üìÑ R√©cup√©ration m√©tadonn√©es pour: ${decodedPath}`);
      
      const metadata = await this.metadataService.getPageMetadata(decodedPath);
      
      return {
        success: true,
        data: metadata,
      };
    } catch (error) {
      this.logger.error(`‚ùå Erreur r√©cup√©ration m√©tadonn√©es pour ${path}:`, error);
      throw new HttpException(
        'Erreur lors de la r√©cup√©ration des m√©tadonn√©es',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }

  /**
   * Mettre √† jour les m√©tadonn√©es d'une page
   * PUT /api/metadata/:path
   */
  @Put(':path(*)')
  async updateMetadata(
    @Param('path') path: string,
    @Body() updateData: MetadataUpdateData,
  ): Promise<{ success: boolean; data: PageMetadata }> {
    try {
      const decodedPath = path ? '/' + decodeURIComponent(path) : '/';
      
      this.logger.log(`üíæ Mise √† jour m√©tadonn√©es pour: ${decodedPath}`);
      
      const metadata = await this.metadataService.updatePageMetadata(decodedPath, updateData);
      
      return {
        success: true,
        data: metadata,
      };
    } catch (error) {
      this.logger.error(`‚ùå Erreur mise √† jour m√©tadonn√©es pour ${path}:`, error);
      throw new HttpException(
        'Erreur lors de la mise √† jour des m√©tadonn√©es',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }

  /**
   * Supprimer les m√©tadonn√©es d'une page
   * DELETE /api/metadata/:path
   */
  @Delete(':path(*)')
  async deleteMetadata(@Param('path') path: string): Promise<{ success: boolean; message: string }> {
    try {
      const decodedPath = path ? '/' + decodeURIComponent(path) : '/';
      
      this.logger.log(`üóëÔ∏è Suppression m√©tadonn√©es pour: ${decodedPath}`);
      
      await this.metadataService.deletePageMetadata(decodedPath);
      
      return {
        success: true,
        message: 'M√©tadonn√©es supprim√©es avec succ√®s',
      };
    } catch (error) {
      this.logger.error(`‚ùå Erreur suppression m√©tadonn√©es pour ${path}:`, error);
      throw new HttpException(
        'Erreur lors de la suppression des m√©tadonn√©es',
        HttpStatus.INTERNAL_SERVER_ERROR,
      );
    }
  }
}