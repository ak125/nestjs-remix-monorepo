/**
 * üöó SERVICE V√âHICULES UNIFI√â - Migration types partag√©s
 * 
 * Service NestJS utilisant les types unifi√©s @monorepo/shared-types
 * D√©monstration de l'int√©gration backend avec types partag√©s
 */

import { Injectable } from '@nestjs/common';
import type {
  VehicleBrand,
  VehicleModel,
  VehicleType,
  ApiResponse,
  PaginationOptions,
  createSuccessResponse,
  createErrorResponse,
} from '@monorepo/shared-types';

// Import des fonctions utilitaires
import { 
  createSuccessResponse as createSuccess,
  createErrorResponse as createError,
  validateVehicleBrand,
} from '@monorepo/shared-types';

import { SupabaseService } from '../../../database/supabase/supabase.service';

// Type temporaire √©tendu pour les options de recherche  
interface SearchablePaginationOptions extends PaginationOptions {
  search?: string;
}

@Injectable()
export class VehicleUnifiedService {
  
  constructor(private readonly supabaseService: SupabaseService) {}

  /**
   * R√©cup√®re toutes les marques avec types unifi√©s
   */
  async getBrands(
    options: SearchablePaginationOptions = { page: 1, limit: 50 },
  ): Promise<ApiResponse<VehicleBrand[]>> {
    try {
      const supabase = this.supabaseService.getClient();
      
      let query = supabase
        .from('auto_marque')
        .select('*')
        .eq('marque_display', 1);

      if (options.search) {
        query = query.ilike('marque_name', `%${options.search}%`);
      }

      const { data, error, count } = await query
        .range(
          (options.page - 1) * options.limit,
          options.page * options.limit - 1
        )
        .order('marque_name');

      if (error) {
        return createError('DATABASE_ERROR', `Erreur r√©cup√©ration marques: ${error.message}`);
      }

      // Validation avec Zod des donn√©es r√©cup√©r√©es
      const validatedBrands = data?.map(brand => {
        try {
          return validateVehicleBrand(brand);
        } catch (validationError) {
          console.warn('‚ö†Ô∏è Marque invalide ignor√©e:', brand, validationError);
          return null;
        }
      }).filter((brand): brand is VehicleBrand => brand !== null) || [];

      return createSuccess(
        validatedBrands,
        `${validatedBrands.length} marques r√©cup√©r√©es avec succ√®s`,
        {
          total: count || 0,
          page: options.page,
          limit: options.limit,
        }
      );

    } catch (error) {
      return createError('UNEXPECTED_ERROR', `Erreur inattendue: ${error.message}`);
    }
  }

  /**
   * R√©cup√®re les mod√®les d'une marque avec types unifi√©s
   */
  async getModelsByBrand(brandId: number, options: PaginationOptions = { page: 1, limit: 50 }): Promise<ApiResponse<VehicleModel[]>> {
    try {
      const supabase = this.supabaseService.getClient();
      
      let query = supabase
        .from('auto_modele')
        .select('*')
        .eq('modele_marque_id', brandId)
        .eq('modele_display', 1);

      if (options.search) {
        query = query.ilike('modele_name', `%${options.search}%`);
      }

      const { data, error, count } = await query
        .range(
          (options.page - 1) * options.limit,
          options.page * options.limit - 1
        )
        .order('modele_name');

      if (error) {
        return createError('DATABASE_ERROR', `Erreur r√©cup√©ration mod√®les: ${error.message}`);
      }

      // Cast vers VehicleModel (pas de validation Zod pour les mod√®les dans ce exemple)
      const models = (data || []) as VehicleModel[];

      return createSuccess(
        models,
        `${models.length} mod√®les r√©cup√©r√©s pour la marque ${brandId}`,
        {
          total: count || 0,
          page: options.page,
          limit: options.limit,
        }
      );

    } catch (error) {
      return createError('UNEXPECTED_ERROR', `Erreur inattendue: ${error.message}`);
    }
  }

  /**
   * R√©cup√®re les types d'un mod√®le avec types unifi√©s
   */
  async getTypesByModel(modelId: number, options: PaginationOptions = { page: 1, limit: 50 }): Promise<ApiResponse<VehicleType[]>> {
    try {
      const supabase = this.supabaseService.getClient();
      
      let query = supabase
        .from('auto_type')
        .select('*')
        .eq('type_modele_id', modelId)
        .eq('type_display', 1);

      if (options.search) {
        query = query.ilike('type_name', `%${options.search}%`);
      }

      const { data, error, count } = await query
        .range(
          (options.page - 1) * options.limit,
          options.page * options.limit - 1
        )
        .order('type_name');

      if (error) {
        return createError('DATABASE_ERROR', `Erreur r√©cup√©ration types: ${error.message}`);
      }

      // Cast vers VehicleType
      const types = (data || []) as VehicleType[];

      return createSuccess(
        types,
        `${types.length} types r√©cup√©r√©s pour le mod√®le ${modelId}`,
        {
          total: count || 0,
          page: options.page,
          limit: options.limit,
        }
      );

    } catch (error) {
      return createError('UNEXPECTED_ERROR', `Erreur inattendue: ${error.message}`);
    }
  }

  /**
   * Test de compatibilit√© avec les types unifi√©s
   */
  async testUnifiedTypes(): Promise<ApiResponse<{
    packageVersion: string;
    typesWorking: boolean;
    validationWorking: boolean;
    apiResponseWorking: boolean;
  }>> {
    try {
      // Test cr√©ation d'une marque factice
      const testBrand: VehicleBrand = {
        marque_id: 999,
        marque_name: 'Test Brand',
        marque_alias: 'test',
        marque_display: 1,
        marque_relfollow: 1,
        marque_sitemap: 1,
      };

      // Test validation Zod
      let validationWorking = false;
      try {
        const validated = validateVehicleBrand(testBrand);
        validationWorking = validated.marque_name === 'Test Brand';
      } catch (error) {
        console.error('‚ùå Validation Zod √©chou√©e:', error);
      }

      // Test cr√©ation r√©ponse API
      const testResponse = createSuccess([testBrand], 'Test r√©ussi');
      const apiResponseWorking = testResponse.success && testResponse.data?.length === 1;

      return createSuccess({
        packageVersion: '2.0.0',
        typesWorking: true,
        validationWorking,
        apiResponseWorking,
      }, 'Tests des types unifi√©s termin√©s');

    } catch (error) {
      return createError('TEST_ERROR', `Erreur tests: ${error.message}`);
    }
  }
}