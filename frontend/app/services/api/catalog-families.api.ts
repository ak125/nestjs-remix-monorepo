// üèóÔ∏è Service API pour r√©cup√©rer les vraies familles de catalogue
// Utilise les endpoints backend avec tables minuscules pour Supabase

// ‚úÖ CORRECTION : URL absolue pour √©viter l'erreur "Invalid URL"
const API_BASE_URL = typeof window === 'undefined' 
  ? 'http://localhost:3000/api'  // C√¥t√© serveur (SSR)
  : '/api';  // C√¥t√© client (navigateur)

export class ApiError extends Error {
  constructor(message: string, public status?: number) {
    super(message);
    this.name = 'ApiError';
  }
}

export interface CatalogGamme {
  pg_id: number;
  pg_alias: string;
  pg_name: string;
  pg_image?: string;
}

export interface CatalogFamily {
  mf_id: number;
  mf_name: string;
  mf_description?: string;
  mf_pic?: string;
  gammes: CatalogGamme[];
}

export interface PopularPart {
  cgc_pg_id: number;
  pg_alias: string;
  pg_name: string;
  pg_name_meta: string;
  pg_img: string;
  addon_content: string;
}

export interface HierarchyResponse {
  hierarchy: {
    [familyId: string]: {
      family: {
        mf_id: string;
        mf_name: string;
        mf_description?: string;
        mf_pic?: string;
      };
      gammes: Array<{
        pg_id: string;
        pg_alias: string;
        pg_name: string;
        pg_image?: string;
      }>;
    };
  };
  success: boolean;
  stats: {
    totalFamilies: number;
    totalGammes: number;
  };
}

/**
 * üéØ Service API pour les familles de catalogue
 * Centralise tous les appels vers le backend
 */
export class CatalogFamiliesApi {
  private baseUrl = API_BASE_URL;

  /**
   * üöó V2: R√©cup√®re les familles de catalogue filtr√©es par v√©hicule
   */
  async getCatalogFamiliesForVehicle(typeId: number): Promise<CatalogFamily[]> {
    try {
      console.log(`üöó [API V2] R√©cup√©ration catalogue filtr√© pour type_id: ${typeId}`);
      
      const response = await fetch(`${this.baseUrl}/catalog/families/vehicle/${typeId}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      });

      if (!response.ok) {
        throw new ApiError(`HTTP error! status: ${response.status}`, response.status);
      }

      const data = await response.json();
      
      if (!data.success) {
        console.warn(`‚ö†Ô∏è Catalogue V2 filtr√©: ${data.message}`);
        return []; // Retour vide si pas de pi√®ces compatibles
      }

      console.log(`‚úÖ [API V2] ${data.totalFamilies} familles filtr√©es r√©cup√©r√©es`);
      return data.families || [];

    } catch (error) {
      console.error('‚ùå [API V2] Erreur r√©cup√©ration catalogue filtr√©:', error);
      throw error;
    }
  }

  /**
   * üöó V3 HYBRIDE: R√©cup√®re le catalogue filtr√© par v√©hicule avec approche hybride optimis√©e
   * Utilise index composite + validation FK pour performance + int√©grit√©
   */
  async getCatalogFamiliesForVehicleV3(typeId: number): Promise<{
    catalog: CatalogFamily[];
    popularParts: PopularPart[];
    queryType: string;
    seoValid: boolean;
  }> {
    try {
      console.log(`üöó [API V3 HYBRIDE] R√©cup√©ration catalogue avec approche hybride pour type_id: ${typeId}`);
      
      const response = await fetch(`${this.baseUrl}/catalog/families/vehicle-v3/${typeId}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        }
      });

      if (!response.ok) {
        throw new ApiError(`Erreur HTTP V3 HYBRIDE: ${response.status}`, response.status);
      }

      const data = await response.json();
      
      if (!data.success || !data.catalog) {
        throw new ApiError(`R√©ponse V3 HYBRIDE invalide: ${data.message || 'Catalogue manquant'}`, 500);
      }
      
      // Transformer les familles du backend vers le format frontend
      const transformedCatalog: CatalogFamily[] = data.catalog.families?.map((family: any) => ({
        mf_id: family.mf_id,
        mf_name: family.mf_name,
        mf_description: family.mf_description || `Syst√®me ${family.mf_name.toLowerCase()}`,
        mf_pic: family.mf_pic || `${family.mf_name.toLowerCase().replace(/\s+/g, '_')}.webp`,
        gammes: family.gammes?.map((gamme: any) => ({
          pg_id: gamme.pg_id,
          pg_alias: gamme.pg_alias,
          pg_name: gamme.pg_name,
          pg_image: gamme.pg_img
        })) || []
      })) || [];
      
      // Transformer les pi√®ces populaires (si disponibles)
      const transformedPopularParts: PopularPart[] = data.popularParts?.map((part: any) => ({
        cgc_pg_id: part.cgc_pg_id || part.pg_id,
        pg_alias: part.pg_alias,
        pg_name: part.pg_name,
        pg_name_meta: part.pg_name_meta || part.pg_name.toLowerCase(),
        pg_img: part.pg_img || 'no.png',
        addon_content: `Trouvez ${part.pg_name} pas cher, d'origine √† prix bas.`
      })) || [];
      
      const queryType = data.catalog.queryType || 'UNKNOWN';
      const seoValid = data.catalog.seoValid || false;
      
      console.log(`‚úÖ [API V3 HYBRIDE] ${transformedCatalog.length} familles (${queryType}), ${transformedPopularParts.length} pi√®ces populaires, SEO: ${seoValid}`);
      
      return {
        catalog: transformedCatalog,
        popularParts: transformedPopularParts,
        queryType,
        seoValid
      };
      
    } catch (error) {
      console.error('‚ùå [API V3 HYBRIDE] Erreur r√©cup√©ration catalogue:', error);
      
      // En cas d'erreur, fallback vers V2
      console.log('üîÑ [API V3 HYBRIDE] Fallback vers V2...');
      try {
        const fallbackData = await this.getCatalogFamiliesForVehicle(typeId);
        return {
          catalog: fallbackData,
          popularParts: [],
          queryType: 'V2_FALLBACK',
          seoValid: false
        };
      } catch (fallbackError) {
        console.error('‚ùå [API V3 HYBRIDE] Erreur fallback V2:', fallbackError);
        throw error; // Throw original V3 error
      }
    }
  }

  /**
   * üöÄ V4 HYBRIDE ULTIME: Cache intelligent + requ√™tes parall√®les + TTL adaptatif
   * Performance ultime avec cache m√©moire et pr√©-calcul background
   */
  async getCatalogFamiliesForVehicleV4(typeId: number): Promise<{
    catalog: CatalogFamily[];
    popularParts: PopularPart[];
    queryType: string;
    seoValid: boolean;
    performance: {
      responseTime: string;
      source: 'CACHE' | 'DATABASE' | 'PRECOMPUTED';
      cacheHitRatio: number;
      completenessScore: number;
    };
  }> {
    try {
      console.log(`üöÄ [API V4 ULTIMATE] R√©cup√©ration catalogue hybride ultime pour type_id: ${typeId}`);
      
      const response = await fetch(`${this.baseUrl}/catalog/families/vehicle-v4/${typeId}`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        }
      });

      if (!response.ok) {
        throw new ApiError(`Erreur HTTP V4 ULTIMATE: ${response.status}`, response.status);
      }

      const data = await response.json();
      
      if (!data.success || !data.catalog) {
        throw new ApiError(`R√©ponse V4 ULTIMATE invalide: ${data.error || 'Catalogue manquant'}`, 500);
      }
      
      // Transformer les familles du backend vers le format frontend
      const transformedCatalog: CatalogFamily[] = data.catalog.families?.map((family: any) => ({
        mf_id: family.mf_id,
        mf_name: family.mf_name,
        mf_description: family.mf_description || `Syst√®me ${family.mf_name.toLowerCase()}`,
        mf_pic: family.mf_pic || `${family.mf_name.toLowerCase().replace(/\s+/g, '_')}.webp`,
        gammes: family.gammes?.map((gamme: any) => ({
          pg_id: gamme.pg_id,
          pg_alias: gamme.pg_alias,
          pg_name: gamme.pg_name,
          pg_image: gamme.pg_img
        })) || []
      })) || [];
      
      // G√©n√©rer les pi√®ces populaires depuis le catalogue (pas d'endpoint sp√©cifique)
      const transformedPopularParts: PopularPart[] = this.generatePopularParts(
        transformedCatalog, 
        `Type ${typeId}`,
        typeId
      );
      
      const queryType = data.catalog.queryType || 'V4_HYBRID_ULTIMATE';
      const seoValid = true; // V4 est toujours SEO valide
      
      console.log(`‚úÖ [API V4 ULTIMATE] ${transformedCatalog.length} familles (${queryType}), ${transformedPopularParts.length} pi√®ces populaires, Cache: ${data.performance?.source}, ${data.performance?.responseTime}`);
      
      return {
        catalog: transformedCatalog,
        popularParts: transformedPopularParts,
        queryType,
        seoValid,
        performance: data.performance || {
          responseTime: '0ms',
          source: 'DATABASE',
          cacheHitRatio: 0,
          completenessScore: 100
        }
      };
      
    } catch (error) {
      console.error('‚ùå [API V4 ULTIMATE] Erreur r√©cup√©ration catalogue:', error);
      
      // En cas d'erreur, fallback vers V3
      console.log('üîÑ [API V4 ULTIMATE] Fallback vers V3...');
      try {
        const fallbackData = await this.getCatalogFamiliesForVehicleV3(typeId);
        return {
          ...fallbackData,
          performance: {
            responseTime: '0ms',
            source: 'DATABASE',
            cacheHitRatio: 0,
            completenessScore: 90
          }
        };
      } catch (fallbackError) {
        console.error('‚ùå [API V4 ULTIMATE] Erreur fallback V3:', fallbackError);
        throw error; // Throw original V4 error
      }
    }
  }

  /**
   * üìä R√©cup√®re les m√©triques avanc√©es V4
   */
  async getV4Metrics(): Promise<{
    service: string;
    performance: {
      totalRequests: number;
      cacheHitRatio: string;
      avgResponseTime: number;
      totalCachedVehicles: number;
    };
    topVehicles: Array<{
      typeId: number;
      requestCount: number;
      lastAccessed: Date;
      avgResponseTime: number;
    }>;
  }> {
    try {
      const response = await fetch(`${this.baseUrl}/catalog/families/metrics-v4`);
      
      if (!response.ok) {
        throw new ApiError(`Erreur m√©triques V4: ${response.status}`, response.status);
      }
      
      const data = await response.json();
      return data.metrics;
      
    } catch (error) {
      console.error('‚ùå [API V4] Erreur r√©cup√©ration m√©triques:', error);
      throw error;
    }
  }
  async getCatalogFamilies(): Promise<CatalogFamily[]> {
    try {
      const response = await fetch(`${this.baseUrl}/catalog/hierarchy/full`, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      });

      if (!response.ok) {
        throw new ApiError(`HTTP error! status: ${response.status}`, response.status);
      }

      const data: HierarchyResponse = await response.json();
      
      // Convertir la structure hi√©rarchie en array de familles
      const families: CatalogFamily[] = Object.values(data.hierarchy).map(item => ({
        mf_id: parseInt(item.family.mf_id),
        mf_name: item.family.mf_name,
        mf_description: item.family.mf_description,
        mf_pic: item.family.mf_pic,
        gammes: item.gammes.map(gamme => ({
          pg_id: parseInt(gamme.pg_id),
          pg_alias: gamme.pg_alias,
          pg_name: gamme.pg_name,
          pg_image: gamme.pg_image
        }))
      }));

      console.log(`‚úÖ ${families.length} familles de catalogue r√©cup√©r√©es depuis la hi√©rarchie`);
      return families;

    } catch (error) {
      console.error('‚ùå Erreur r√©cup√©ration familles catalogue:', error);
      throw error;
    }
  }

  /**
   * üéØ G√©n√®re les pi√®ces populaires bas√©es sur les vraies donn√©es
   */
  generatePopularParts(families: CatalogFamily[], vehicleName: string, typeId: number): PopularPart[] {
    const popularParts: PopularPart[] = [];
    
    // S√©lectionner les pi√®ces les plus communes (bas√© sur les vrais alias de la DB)
    const commonPartNames = ['filtre-a', 'plaquette', 'disque', 'courroie', 'bougie', 'rotule'];
    
    console.log(`üîç Recherche de pi√®ces populaires dans ${families.length} familles...`);
    
    families.forEach(family => {
      family.gammes.forEach(gamme => {
        // Chercher les pi√®ces communes (recherche plus flexible)
        const isCommon = commonPartNames.some(common => 
          gamme.pg_alias.toLowerCase().includes(common.toLowerCase()) ||
          gamme.pg_name.toLowerCase().includes(common.toLowerCase())
        );
        
        if (isCommon && popularParts.length < 6) { // R√©cup√©rer plus pour avoir du choix
          console.log(`‚úÖ Pi√®ce populaire trouv√©e: ${gamme.pg_name} (${gamme.pg_alias})`);
          popularParts.push({
            cgc_pg_id: gamme.pg_id,
            pg_alias: gamme.pg_alias,
            pg_name: gamme.pg_name,
            pg_name_meta: gamme.pg_name.toLowerCase(),
            pg_img: gamme.pg_image || `${gamme.pg_alias}.webp`,
            addon_content: this.generateSeoContent(gamme.pg_name, vehicleName, typeId + popularParts.length)
          });
        }
      });
    });

    console.log(`üéØ ${popularParts.length} pi√®ces populaires g√©n√©r√©es depuis ${families.length} familles`);
    
    // Limiter √† 3 pi√®ces populaires mais assurer qu'on en a au moins quelques unes
    return popularParts.slice(0, 3);
  }

  /**
   * üîÑ G√©n√®re le contenu SEO pour une pi√®ce
   */
  private generateSeoContent(pgName: string, vehicleName: string, typeId: number): string {
    const switches = ["Achetez", "Trouvez", "Commandez", "Choisissez"];
    const qualities = ["d'origine", "de qualit√©", "certifi√©es", "garanties"];
    const switchIndex = typeId % switches.length;
    const qualityIndex = (typeId + 1) % qualities.length;
    
    return `${switches[switchIndex]} ${pgName.toLowerCase()} ${vehicleName}, ${qualities[qualityIndex]} √† prix bas.`;
  }
}

// Instance singleton pour l'export
export const catalogFamiliesApi = new CatalogFamiliesApi();